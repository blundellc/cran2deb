#!/usr/bin/env r

maintainer <- 'cran2deb buildbot <cran2deb@example.org>'
root <- '/home/cb/work/gsoc/cran2deb'
pbuilder_results <- file.path(root,'var/results')
pbuilder_config  <- file.path(root,'etc/pbuilderrc')
dput_config      <- file.path(root,'etc/dput.cf')
dinstall_config  <- file.path(root,'etc/mini-dinstall.conf')
dinstall_archive <- file.path(root,'var/archive')
r_depend_fields  <- c('Depends','Imports') # Suggests, Enhances

# we cache the list of available packages
load(file.path(root,'var/cache/available.cache.Rd'))

version.new <- function(rver,debian_revision=1, debian_epoch=0) {
    # generate a string representation of the Debian version of an
    # R version of a package
    pkgver = rver

    # ``Writing R extensions'' says that the version consists of at least two
    # non-negative integers, separated by . or -
    if (!length(grep('^([0-9]+[.-])+[0-9]+$',rver))) {
        stop(paste('Not a valid R package version',rver))
    }

    # Debian policy says that an upstream version should start with a digit and
    # may only contain ASCII alphanumerics and '.+-:~'
    if (!length(grep('^[0-9][A-Za-z0-9.+:~-]*$',rver))) {
        stop(paste('R package version',rver
                  ,'does not obviously translate into a valid Debian version.'))
    }

    # if rver contains a : then the Debian version must also have a colon
    if (debian_epoch == 0 && length(grep(':',pkgver)))
        debian_epoch = 1

    # if the epoch is non-zero then include it
    if (debian_epoch != 0)
        pkgver = paste(debian_epoch,':',pkgver,sep='')

    # always add the '-1' Debian release; nothing is lost and rarely will R
    # packages be Debian packages without modification.
    return(paste(pkgver,'-',debian_revision,sep=''))
}

version.epoch <- function(pkgver) {
    # return the Debian epoch of a Debian package version
    if (!length(grep(':',pkgver)))
        return(0)
    return(as.integer(sub('^([0-9]+):.*','\\1',pkgver)))
}
# version.epoch . version.new(x,y) = id
# version.epoch(version.new(x,y)) = 0

version.revision <- function(pkgver) {
    # return the Debian revision of a Debian package version
    return(as.integer(sub('.*-([0-9]+)$','\\1',pkgver)))
}
# version.revision . version.new(x) = id
# version.revision(version.new(x)) = 1

version.upstream <- function(pkgver) {
    # return the upstream version of a Debian package version
    return(sub('-[0-9]+$','',sub('^[0-9]+:','',pkgver)))
}
# version.upstream . version.new = id

version.update <- function(rver, prev_pkgver) {
    prev_rver <- version.upstream(prev_pkgver)
    if (prev_rver == rver) {
        # increment the Debian revision
        return(version.new(rver
                          ,debian_revision = version.revision(prev_pkgver)+1
                          ,debian_epoch    = version.epoch(prev_pkgver)
                          ))
    }
    # new release
    # TODO: implement Debian ordering over version and then autoincrement
    #       Debian epoch when upstream version does not increment.
    return(version.new(rver
                      ,debian_epoch = version.epoch(prev_pkgver)
                      ))
}

# sudo pbuilder --execute r -e 'rownames(installed.packages())'
# XXX: has to be a better way of doing this
base_pkgs=c('base',   'datasets','grDevices','graphics','grid', 'methods'
           ,'splines','stats',   'stats4',   'tcltk',   'tools','utils')
# found in R source directory:
# 'profile', 'datasets'

repourl.as.debian <- function(url) {
    if (length(grep('cran',url))) {
        return('cran')
    }
    if (length(grep('bioc',url))) {
        return('bioc')
    }
    stop(paste('unknown repository',url))
}

pkgname.as.debian <- function(name,repopref=NULL,version=NULL,binary=T) {
    if (name %in% base_pkgs) {
        name = 'R'
    }
    if (name == 'R') {
        # R is special.
        if (binary) {
            debname='r-base-core'
        } else {
            debname='r-base-dev'
        }
    } else {
        # XXX: data.frame rownames are unique, so always override repopref for
        #      now.
        if (!(name %in% rownames(available))) {
            bundle <- r.bundle.of(name)
            if (is.na(bundle)) {
                stop(paste('package',name,'is not available'))
            }
            name <- bundle
        }
        repopref <- repourl.as.debian(available[name,'Repository'])
        debname = paste('r',tolower(repopref),tolower(name),sep='-')
    }
    if (!is.null(version) && length(version) > 1) {
        debname = paste(debname,' (',version,')',sep='')
    }
    return(debname)
}

setup <- function() {
    tmp <- tempfile('cran2deb')
    dir.create(tmp)
    return (tmp)
}

cleanup <- function(dir) {
    unlink(dir,recursive=T)
    invisible()
}

r.bundle.of <- function(pkgname) {
    bundles <- available[!is.na(available[, "Bundle"]), "Contains"]
    # use the first bundle
    for (bundle in names(bundles)) {
        content <- strsplit(bundles[[bundle]],'[[:space:]]+')[[1]]
        if (pkgname %in% content) {
            return(bundle)
        }
    }
    return(NA)
}

prepare.pkg <- function(dir, pkgname) {
    # based loosely on library/utils/R/packages2.R::install.packages
    # should do nothing Debian specific

    # first a little trick; change pkgname if pkgname is contained in a bundle
    if (!(pkgname %in% rownames(available))) {
        bundle <- r.bundle.of(pkgname)
        if (is.na(bundle)) {
            stop(paste('package',pkgname,'is unavailable'))
        }
        pkgname <- bundle
    }
    archive <- download.packages(pkgname, dir, available=available, repos='', type="source")[1,2]
    if (length(grep('\\.\\.',archive)) || normalizePath(archive) != archive) {
        stop(paste('funny looking path',archive))
    }
    wd <- getwd()
    setwd(dir)
    if (length(grep('\\.zip$',archive))) {
        cmd = paste('unzip',shQuote(archive))
    } else if (length(grep('\\.tar\\.gz$',archive))) {
        cmd = paste('tar','xzf',shQuote(archive))
    } else {
        stop(paste('Type of archive',archive,'is unknown.'))
    }
    ret = system(cmd)
    setwd(wd)
    if (ret != 0) {
        stop(paste('Extraction of archive',archive,'failed.'))
    }
    pkg <- pairlist()
    pkg$name = pkgname
    pkg$archive = archive
    pkg$path = sub("_\\.(zip|tar\\.gz)", ""
                  ,gsub(.standard_regexps()$valid_package_version, ""
                  ,archive))
    if (!file.info(pkg$path)[,'isdir']) {
        stop(paste(pkg$path,'is not a directory and should be.'))
    }
    pkg$description = read.dcf(file.path(pkg$path,'DESCRIPTION'))
    pkg$repoURL = available[pkgname,'Repository']
    pkg$version = pkg$description[1,'Version']
    pkg$is_bundle = 'Bundle' %in% names(pkg$description[1,])
    # note subtly of short circuit operators (no absorption)
    if ((!pkg$is_bundle && pkg$description[1,'Package'] != pkg$name) ||
        ( pkg$is_bundle && pkg$description[1,'Bundle'] != pkg$name)) {
        stop(paste('package name mismatch'))
    }
    return(pkg)
}

debian_ok_licenses=c('GPL','LGPL','AGPL','ARTISTIC' #,'UNLIMITED'
                    ,'BSD','MIT','APACHE','X11','MPL')

is_acceptable_license <- function(license) {
    # compress spaces into a single space
    license = gsub('[[:blank:]]+',' ',license)
    # make all characters upper case
    license = toupper(license)
    # don't care about versions of licenses
    license = chomp(sub('\\( ?[<=>!]+ ?[0-9.-]+ ?\\)',''
                    ,sub('-[0-9.-]+','',license)))
    if (license %in% debian_ok_licenses) {
        return(T)
    }
    # uninteresting urls
    license = gsub('\\(?HTTP://WWW.GNU.ORG/[A-Z/._-]*\\)?','',license)
    license = gsub('\\(?HTTP://WWW.X.ORG/[A-Z/._-]*\\)?','',license)
    # remove all punctuation
    license = gsub('[[:punct:]]+','',license)
    # remove any extra space introduced
    license = chomp(gsub('[[:space:]]+',' ',license))
    # redundant
    license = gsub('THE','',license)
    license = gsub('STANDARD','',license)
    license = gsub('LICEN[SC]E','',license)
    license = gsub('(GNU )?(GPL|GENERAL PUBLIC)','GPL',license)
    license = gsub('(MOZILLA )?(MPL|MOZILLA PUBLIC)','MPL',license)
    # remove any extra space introduced
    license = chomp(gsub('[[:space:]]+',' ',license))
    if (license %in% debian_ok_licenses) {
        message(paste('W: Accepted wild license as',license,'. FIX THE PACKAGE!'))
        return(T)
    }
    # remove everything that looks like a version specification
    license = gsub('(VERSION|V)? *[0-9.-]+ *(OR *(HIGHER|LATER|NEWER|GREATER|ABOVE))?',''
                   ,license)
    # remove any extra space introduced
    license = chomp(gsub('[[:space:]]+',' ',license))
    if (license %in% debian_ok_licenses) {
        message(paste('W: Accepted wild license as',license,'. FIX THE PACKAGE!'))
        return(T)
    }
    # TODO: put debian_ok_licenses in DB
    # TODO: file {LICENSE,LICENCE} (+ maybe COPYING?)
    message(paste('E: Wild license',license,'did not match'))
    return(F)
}

chomp <- function(x) {
    return(sub('^[[:space:]]+','',sub('[[:space:]]+$','',x)))
}

host.arch <- function() {
    system('dpkg-architecture -qDEB_HOST_ARCH',intern=T)
}

r.dependencies.of <- function(name=NULL,description=NULL) {
    if (!is.null(name) && (name == 'R' || name %in% base_pkgs)) {
        return(data.frame())
    }
    if (is.null(description) && is.null(name)) {
        stop('must specify either a description or a name.')
    }
    if (is.null(description)) {
        if (!(name %in% rownames(available))) {
            bundle <- r.bundle.of(name)
            if (is.na(bundle)) {
                stop(paste('package',name,'is not available'))
            }
            name <- bundle
        }
        description <- data.frame()
        # keep only the interesting fields
        for (field in r_depend_fields) {
            if (!(field %in% names(available[name,]))) {
                next
            }
            description[1,field] = available[name,field]
        }
    }
    # extract the dependencies from the description
    deps <- data.frame()
    for (field in r_depend_fields) {
        if (!(field %in% names(description[1,]))) {
            next
        }
        for (dep in strsplit(chomp(description[1,field])
                                  ,'[[:space:]]*,[[:space:]]*')[[1]]) {
            if (is.na(dep)) {
                # XXX: this may be a bug, but for some reason NA's appear in
                #      this field at the end?
                next
            }
            # remove other comments
            dep = gsub('(\\(\\)|\\([[:space:]]*[^<=>!].*\\))','',dep)
            # squish spaces
            dep = chomp(gsub('[[:space:]]+',' ',dep))
            # parse version
            pat = '^([^ ()]+) ?(\\( ?([<=>!]+ ?[0-9.-]+) ?\\))?$'
            if (!length(grep(pat,dep))) {
                stop(paste('R dependency',dep,'does not appear to be well-formed'))
            }
            version = sub(pat,'\\3',dep)
            dep = sub(pat,'\\1',dep)
            deps <- rbind(deps,data.frame(list(name=dep
                                              ,version=version)))
        }
    }
    return (deps)
}

r.dependency.closure <- function(fringe) {
    closure <- list()
    if (is.data.frame(fringe)) {
        fringe <- levels(fringe$name)
    }
    while(length(fringe) > 0) {
        # pop off the top
        top <- fringe[[1]]
        if (length(fringe) > 1) {
            fringe <- fringe[2:length(fringe)]
        } else {
            fringe <- list()
        }
        src <- pkgname.as.debian(top,binary=F)
        if (!length(grep('^r-',src)) || length(grep('^r-base',src))) {
            next
        }
        newdeps <- levels(r.dependencies.of(name=top)$name)
        closure=c(closure,top)
        fringe=c(fringe,newdeps)
    }
    # build order
    return(rev(unique(closure,fromLast=T)))
}

accept.license <- function(pkg) {
    # check the license
    if (!('License' %in% names(pkg$description[1,]))) {
        stop('package has no License: field in description!')
    }
    accept=NULL
    for (license in strsplit(chomp(pkg$description[1,'License'])
                            ,'[[:space:]]*\\|[[:space:]]*')[[1]]) {
        if (is_acceptable_license(license)) {
            accept=license
            break
        }
    }
    if (is.null(accept)) {
        stop(paste('No acceptable license:',pkg$description[1,'License']))
    } else {
        message(paste('N: Auto-accepted license',accept))
    }
    if (accept == 'Unlimited') {
        # definition of Unlimited from ``Writing R extensions''
        accept=paste('Unlimited (no restrictions on distribution or'
                    ,'use other than those imposed by relevant laws)')
    }
    return(accept)
}

generate.changelog <- function(pkg) {
    # construct a dummy changelog
    # TODO: ``Writing R extensions'' mentions that a package may also have
    # {NEWS,ChangeLog} files.
    cat(paste(paste(pkg$srcname,' (',pkg$debversion,') unstable; urgency=low',sep='')
             ,'' ,'  * Initial release.',''
             ,paste(' --',maintainer,'',format(Sys.time(),'%a, %d %b %Y %H:%M:%S %z'))
             ,'',sep='\n'),file=pkg$debfile('changelog.in'))
}

generate.rules <- function(pkg) {
    cat(paste('#!/usr/bin/make -f'
             ,'include /usr/share/R/debian/r-cran.mk'
             ,'',sep='\n')
       ,file=pkg$debfile('rules'))
    Sys.chmod(pkg$debfile('rules'),'0700')
}

generate.copyright <- function(pkg) {
    # generate copyright file; we trust DESCRIPTION
    writeLines(strwrap(
        paste('This Debian package of the GNU R package',pkg$name
             ,'was generated automatically using cran2deb by'
             ,paste(maintainer,'.',sep='')
             ,''
             ,'The original GNU R package is Copyright (C) '
             # TODO: copyright start date, true copyright date
             ,format(Sys.time(),'%Y')
             ,pkg$description[1,'Author']
             ,'and possibly others.'
             ,''
             ,'The original GNU R package is maintained by'
             ,pkg$description[1,'Maintainer'],'and was obtained from:'
             ,''
             ,pkg$repoURL
             ,''
             ,''
             ,'The GNU R package DESCRIPTION offers a'
             ,'Copyright licenses under the terms of the',accept
             ,'license.  On a Debian GNU/Linux system, common'
             ,'licenses are included in the directory'
             ,'/usr/share/common-licenses/.'
             ,''
             ,'The DESCRIPTION file for the original GNU R package '
             ,'can be found in '
             ,file.path('/usr/lib/R/site-library'
                   ,pkg$debname
                   ,'DESCRIPTION'
                   )
             ,sep='\n'), width=72), con=pkg$debfile('copyright.in'))
}

generate.control <- function(pkg) {
    # see if this is an architecture-dependent package.
    # heuristic: if /src/ exists in pkg$path, then this is an
    #            architecture-dependent package.
    # CRAN2DEB.pm is a bit fancier about this but ``Writing R extensions''
    # says: ``The sources and headers for the compiled code are in src, plus
    # optionally file Makevars or Makefile.'' It seems unlikely that
    # architecture independent code would end up here.
    pkg$archdep = file.exists(file.path(pkg$path,'src'))
    pkg$arch <- 'all'
    if (pkg$archdep) {
        pkg$arch <- host.arch()
    }

    # determine dependencies
    dependencies <- r.dependencies.of(description=pkg$description)
    depends <- list()
    # these are used for generating the Depends fields
    as.deb <- function(r,binary) {
        return(pkgname.as.debian(dependencies[r,]$name
                                ,version=dependencies[r,]$version
                                ,repopref=pkg$repo
                                ,binary=binary))
    }
    depends$bin <- lapply(rownames(dependencies), as.deb, binary=T)
    depends$build <- lapply(rownames(dependencies), as.deb, binary=F)

    # make sure we depend upon R in some way...
    if (!length(grep('^r-base',depends$build))) {
        depends$build = c(depends$build,pkgname.as.debian('R',version='>= 2.7.0',binary=F))
        depends$bin   = c(depends$bin,  pkgname.as.debian('R',version='>= 2.7.0',binary=T))
    }

    # remove duplicates
    depends <- lapply(depends,unique)

    # append the Debian dependencies
    depends$build=c(depends$build,'debhelper (>> 4.1.0)','cdbs')
    if (pkg$archdep) {
        depends$bin=c(depends$bin,'${shlibs:Depends}')
    }

    # the names of dependent source packages (to find the .changes file to
    # upload via dput). these can be found recursively.
    pkg$r.depends = lapply(r.dependency.closure(dependencies)
                          ,tolower)

    # construct control file
    control = data.frame()
    control[1,'Source'] = pkg$srcname
    control[1,'Section'] = 'math'
    control[1,'Priority'] = 'optional'
    control[1,'Maintainer'] = maintainer
    control[1,'Build-Depends'] = paste(depends$build,collapse=', ')
    control[1,'Standards-Version'] = '3.7.3.0'

    control[2,'Package'] = pkg$debname
    control[2,'Architecture'] = 'all'
    if (pkg$archdep) {
        control[2,'Architecture'] = 'any'
    }
    control[2,'Depends'] = paste(depends$bin,collapse=', ')
    descr = 'GNU R package "'
    if ('Title' %in% colnames(pkg$description)) {
        descr = paste(descr,pkg$description[1,'Title'],sep='')
    } else {
        descr = paste(descr,pkg$name,sep='')
    }
    # using \n\n.\n\n is not very nice, but is necessary to make sure
    # the longer description does not begin on the synopsis line --- R's
    # write.dcf does not appear to have a nicer way of doing this.
    descr = paste(descr,'"\n\n', pkg$description[1,'Description'], sep='')
    if ('URL' %in% colnames(pkg$description)) {
        descr = paste(descr,'\n\nURL: ',pkg$description[1,'URL'],sep='')
    }
    control[2,'Description'] = descr
    # Debian policy says 72 char width; indent minimally
    write.dcf(control,file=debfile('control.in'),indent=1,width=72)
    write.dcf(control,indent=1,width=72)
}

prepare.new.debian <- function(pkg) {
    # XXX: TODO: bundles do not work.
    if ('Bundle' %in% names(pkg$description[1,])) {
        stop('E: TODO: bundles')
    }

    # generate Debian version and name
    pkg$repo = repourl.as.debian(pkg$repoURL)
    pkg$debversion = version.new(pkg$version)
    if (!length(grep('^[A-Za-z0-9][A-Za-z0-9+.-]+$',pkg$name))) {
        stop(paste('Cannot convert package name into a Debian name',pkg$name))
    }
    pkg$srcname = tolower(pkg$name)
    pkg$debname = pkgname.as.debian(pkg$name,repo=pkg$repo)

    if (!length(grep('\\.tar\\.gz',pkg$archive))) {
        stop('archive is not tarball')
    }

    # re-pack into a Debian-named archive with a Debian-named directory.
    debpath = file.path(dirname(pkg$archive)
                   ,paste(pkg$srcname,'-'
                         ,pkg$version
                         ,sep=''))
    file.rename(pkg$path, debpath)
    pkg$path = debpath
    debarchive = file.path(dirname(pkg$archive)
                          ,paste(pkg$srcname,'_'
                                ,pkg$version,'.orig.tar.gz'
                                ,sep=''))
    wd <- getwd()
    setwd(dirname(pkg$path))
    # remove them pesky +x files
    system(paste('find',shQuote(basename(pkg$path))
                ,'-type f -exec chmod -x {} \\;'))
    # tar it all back up
    system(paste('tar -czf',shQuote(debarchive),shQuote(basename(pkg$path))))
    setwd(wd)
    file.remove(pkg$archive)
    pkg$archive = debarchive

    # make the debian/ directory
    debdir <- file.path(pkg$path,'debian')
    pkg$debfile <- function(x) { file.path(debdir,x) }
    unlink(debdir,recursive=T)
    dir.create(debdir)

    pkg$license <- accept.license(pkg)

    generate.changelog(pkg)
    generate.rules(pkg)
    generate.copyright(pkg)
    generate.control(pkg)

    # TODO: debian/watch from pkg$repoURL

    # convert text to utf8 (who knows what the original character set is --
    # let's hope iconv DTRT).
    for (file in c('control','changelog','copyright')) {
        system(paste('iconv -o ',shQuote(debfile(file))
                    ,' -t utf8 '
                    ,shQuote(debfile(paste(file,'in',sep='.')))))
        file.remove(debfile(paste(file,'in',sep='.')))
    }
    return(pkg)
}

build.debian <- function(pkg) {
    wd <- getwd()
    setwd(pkg$path)
    message(paste('N: building Debian package'
                 ,pkg$debname
                 ,paste('(',pkg$debversion,')',sep='')
                 ,'...'))
    ret = system(paste('pdebuild --configfile',pbuilder_config))
    setwd(wd)
    if (ret != 0) {
        stop('Failed to build package.')
    }
}

changesfile <- function(srcname,version='*') {
    return(file.path(pbuilder_results,
                    ,paste(srcname,'_',version,'_'
                          ,host.arch(),'.changes',sep='')))
}

go <- function(name) {
    dir <- setup()
    pkg <- try((function() {
        pkg <- prepare.new.debian(prepare.pkg(dir,name))
        if (file.exists(changesfile(pkg$srcname,pkg$debversion))) {
            message(paste('N: already built',pkg$srcname,'version',pkg$debversion))
            return(pkg)
        }

        # delete the current archive (XXX: assumes mini-dinstall)
        for (subdir in c('mini-dinstall','unstable')) {
            path = file.path(dinstall_archive,subdir)
            if (file.exists(path)) {
                unlink(path,recursive=T)
            }
        }

        # delete notes of upload
        file.remove(Sys.glob(file.path(pbuilder_results,'*.upload')))

        # make mini-dinstall generate the skeleton of the archive
        ret = system(paste('umask 022;mini-dinstall --batch -c',dinstall_config))
        if (ret != 0) {
            stop('failed to create archive')
        }

        # pull in all the R dependencies
        message(paste('N: dependencies:',pkg$r.depends,collapse=', '))
        for (dep in pkg$r.depends) {
            message(paste('N: uploading',dep))
            ret = system(paste('umask 022;dput','-c',shQuote(dput_config),'local'
                        ,changesfile(dep)))
            if (ret != 0) {
                stop('upload of dependency failed! maybe you did not build it first?')
            }
        }
        build.debian(pkg)

        # upload the package
        ret = system(paste('umask 022;dput','-c',shQuote(dput_config),'local'
                    ,changesfile(pkg$srcname,pkg$debversion)))
        if (ret != 0) {
            stop('upload failed!')
        }

        return(pkg)
    })())
    cleanup(dir)
    if (inherits(pkg,'try-error')) {
        stop(call.=F)
    }
    return(pkg)
}

if (exists('argv')) { # check for littler
    build_order <- r.dependency.closure(argv)
    message(paste('N: build order',paste(build_order,collapse=', ')))
    for (pkg in build_order) {
        go(pkg)
    }
}
