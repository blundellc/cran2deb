#!/usr/bin/env r

version.new <- function(rver,debian_revision=1, debian_epoch=0) {
    # generate a string representation of the Debian version of an
    # R version of a package
    pkgver = rver

    # ``Writing R extensions'' says that the version consists of at least two
    # non-negative integers, separated by . or -
    if (!length(grep('^([0-9]*[1-9][.-])+[0-9]*[1-9]$',rver))) {
        stop(paste('Not a valid R package version',rver))
    }

    # Debian policy says that an upstream version should start with a digit and
    # may only contain ASCII alphanumerics and '.+-:~'
    if (!length(grep('^[0-9][A-Za-z0-9.+:~-]*$',rver))) {
        stop(paste('R package version',rver
                  ,'does not obviously translate into a valid Debian version.'))
    }

    # if rver contains a : then the Debian version must also have a colon
    if (debian_epoch == 0 && length(grep(':',pkgver)))
        debian_epoch = 1

    # if the epoch is non-zero then include it
    if (debian_epoch != 0)
        pkgver = paste(debian_epoch,':',pkgver,sep='')

    # always add the '-1' Debian release; nothing is lost and rarely will R
    # packages be Debian packages without modification.
    return(paste(pkgver,'-',debian_revision,sep=''))
}

version.epoch <- function(pkgver) {
    # return the Debian epoch of a Debian package version
    if (!length(grep(':',pkgver)))
        return(0)
    return(as.integer(sub('^([0-9]+):.*','\\1',pkgver)))
}
# version.epoch . version.new(x,y) = id
# version.epoch(version.new(x,y)) = 0

version.revision <- function(pkgver) {
    # return the Debian revision of a Debian package version
    return(as.integer(sub('.*-([0-9]+)$','\\1',pkgver)))
}
# version.revision . version.new(x) = id
# version.revision(version.new(x)) = 1

version.upstream <- function(pkgver) {
    # return the upstream version of a Debian package version
    return(sub('-[0-9]+$','',sub('^[0-9]+:','',pkgver)))
}
# version.upstream . version.new = id

version.update <- function(rver, prev_pkgver) {
    prev_rver <- version.upstream(prev_pkgver)
    if (prev_rver == rver) {
        # increment the Debian revision
        return(version.new(rver
                          ,debian_revision = version.revision(prev_pkgver)+1
                          ,debian_epoch    = version.epoch(prev_pkgver)
                          ))
    }
    # new release
    # TODO: implement Debian ordering over version and then autoincrement
    #       Debian epoch when upstream version does not increment.
    return(version.new(rver
                      ,debian_epoch = version.epoch(prev_pkgver)
                      ))
}

setup <- function() {
    tmp <- tempfile('cran2deb')
    dir.create(tmp)
    return (tmp)
}

prepare.pkg <- function(dir, pkgname) {
    # based loosely on library/utils/R/packages2.R::install.packages
    # should do nothing Debian specific
    archive <- download.packages(pkgname, dir, type="source")[1,2]
    wd <- getwd()
    setwd(dir)
    if (length(grep('\\.zip$',archive))) {
        cmd = paste('unzip',shQuote(archive))
    } else if (length(grep('\\.tar\\.gz$',archive))) {
        cmd = paste('tar','xzf',shQuote(archive))
    } else {
        stop(paste('Type of archive',archive,'is unknown.'))
    }
    ret = system(cmd)
    setwd(wd)
    if (ret != 0) {
        stop(paste('Extraction of archive',archive,'failed.'))
    }
    pkg <- pairlist()
    pkg$name = pkgname
    pkg$archive = archive
    pkg$path = sub("_\\.(zip|tar\\.gz)", ""
                  ,gsub(.standard_regexps()$valid_package_version, ""
                  ,archive))
    pkg$description = read.dcf(paste(pkg$path,'DESCRIPTION',sep='/'))
    pkg$repo = 'cran'
    pkg$version = pkg$description[1,'Version']
    return(pkg)
}

debian_ok_licenses=c('GPL-2','GPL-3','LGPL-2','LGPL-2.1','LGPL-3'
                    ,'AGPL-3','Artistic-1.0','Artistic-2.0','Unlimited')

chomp <- function(x) {
    return(sub('^[:space:]+','',sub('[:space:]+$','',x)))
}
prepare.new.debian <- function(pkg) {
    maintainer = 'cran2deb buildbot <cran2deb@example.org>'

    if (!length(grep('\\.tar\\.gz',pkg$archive))) {
        stop('archive is not tarball')
    }
    debarchive= paste(dirname(pkg$archive),'/'
                             ,pkg$name,'_'
                             ,pkg$version,'.orig.tar.gz'
                             ,sep='')
    file.rename(pkg$archive, debarchive)
    pkg$archive = debarchive
    # not sure can rename directory from R(!)
    pkg$debversion = version.new(pkg$version)
    pkg$debname = paste('r',pkg$repo,pkg$name,sep='-')
    debdir <- paste(pkg$path,'debian',sep='/')
    debfile <- function(x) { paste(debdir,x,sep='/') }
    unlink(debdir,recursive=T)
    dir.create(debdir)

    # TODO: ``Writing R extensions'' mentions that a package may also have
    # {NEWS,ChangeLog} files.
    cat(paste(paste(pkg$name,' (',pkg$debversion,') unstable; urgency=low',sep='')
             ,'' ,'  * Initial release.',''
             ,paste(' --',maintainer,'',format(Sys.time(),'%a, %d %b %Y %H:%M:%S %z'))
             ,'',sep='\n'),file=debfile('changelog'))
    cat(paste('#!/usr/bin/make -f'
             ,'include /usr/share/R/debian/r-cran.mk'
             ,'',sep='\n')
       ,file=debfile('rules'))
    Sys.chmod(debfile('rules'),'0700')

    # if License: is missing, we must stop!
    if (!('License' %in% names(pkg$description[1,]))) {
        stop('package has no License: field in description!')
    }
    accept=NULL
    for (license in strsplit(chomp(pkg$description[1,'License']),' *\\| *')[[1]]) {
        if (license %in% debian_ok_licenses) {
            accept=license
            break
        }
        # TODO: put debian_ok_licenses in DB
        # TODO: file {LICENSE,LICENCE} (+ maybe COPYING?)
        # TODO: name (op v)
    }
    if (is.null(accept)) {
        stop('No acceptable license.')
    } else {
        message(paste('Auto-accepted license',accept))
    }
    if (accept == 'Unlimited') {
        # definition of Unlimited from ``Writing R extensions''
        accept=paste('Unlimited (no restrictions on distribution or'
                    ,'use other than those imposed by relevant laws)')
    }
    writeLines(strwrap(
        paste('This Debian package of the GNU R package',pkg$name
             ,'was generated using cran2deb by'
             ,paste(maintainer,'.',sep='')
             ,'The author(s) of the original GNU R package were:'
             ,pkg$description[1,'Author']
             ,''
             ,'The original GNU R package is maintained by'
             ,pkg$description[1,'Maintainer'],'and was obtained from:'
             ,''
             ,paste('    ',contrib.url(getOption("repos")))
             ,''
             ,''
             ,'The GNU R package DESCRIPTION offers a'
             ,'Copyright licenses under the terms of the',accept
             ,'license.  On a Debian GNU/Linux system, common'
             ,'licenses are included in the directory'
             ,'/usr/share/common-licenses/.'
             ,''
             ,'The DESCRIPTION file for the original GNU R package '
             ,'can be found in '
             ,paste('/usr/lib/R/site-library'
                   ,pkg$debname
                   ,'DESCRIPTION'
                   ,sep='/')
             ,sep='\n'), width=72), con=debfile('copyright'))

    # heuristic: if /src/ exists in pkg$path, then this is an
    #            architecture-dependent package.
    # CRAN2DEB.pm is a bit fancier about this but ``Writing R extensions''
    # says: ``The sources and headers for the compiled code are in src, plus
    # optionally file Makevars or Makefile.'' It seems unlikely that
    # architecture independent code would end up here.
    archdep = file.exists(paste(pkg$path,'src',sep='/'))
    shlibdep = ''
    if (archdep) {
        shlibdep = '${shlibs:Depends}'
    }
    control = data.frame()
    control[1,'Source'] = pkg$name
    control[1,'Section'] = 'math'
    control[1,'Priority'] = 'optional'
    control[1,'Maintainer'] = maintainer
    control[1,'Build-Depends'] = paste('debhelper (>> 4.1.0)'
                                      ,'r-base-dev (>= 2.7.0)'
                                      ,'cdbs'
                                      ,sep=', ')
    control[1,'Standards-Version'] = '3.7.3.0'

    control[2,'Package'] = pkg$debname
    control[2,'Architecture'] = 'all'
    if (archdep) {
        control[2,'Architecture'] = 'any'
    }
    control[2,'Depends'] = paste('r-base-core', shlibdep, sep=', ')
    control[2,'Description'] = paste('GNU R package "'
                                    ,pkg$description[1,'Title'],'"\n'
                                    ,pkg$description[1,'Description']
                                    ,sep='')
    # Debian policy says 72 char width; indent minimally
    write.dcf(control,file=debfile('control'),indent=1,width=72)
    # TODO: debian/watch

    return(pkg)
}

build.debian <- function(pkg) {
    wd <- getwd()
    setwd(pkg$path)
    message(paste('building Debian package'
                 ,pkg$debname
                 ,paste('(',pkg$debversion,')',sep='')
                 ,'...'))
    system('debuild -us -uc -b')
    setwd(wd)
}

cleanup <- function(dir) {
    unlink(dir, recursive=T)

    invisible()
}


test <- function(name) {
    dir <- setup()
        pkg <- prepare.new.debian(prepare.pkg(dir,name))
        build.debian(pkg)
#    cleanup(dir)
    return(pkg)
}

