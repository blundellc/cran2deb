#!/usr/bin/env r

root <- '/home/cb/work/gsoc/cran2deb'
pbuilder_results <- paste(root,'/var/results',sep='')
pbuilder_config  <- paste(root,'/etc/pbuilderrc',sep='')
dput_config      <- paste(root,'/etc/dput.cf',sep='')
dinstall_config  <- paste(root,'/etc/mini-dinstall.conf',sep='')
dinstall_archive <- paste(root,'/var/archive',sep='')
default_repo     <- 'cran'
default_repo_url <- 'http://cran.uk.r-project.org/'
r_depend_fields  <- c('Depends','Imports') # Suggests, Enhances

version.new <- function(rver,debian_revision=1, debian_epoch=0) {
    # generate a string representation of the Debian version of an
    # R version of a package
    pkgver = rver

    # ``Writing R extensions'' says that the version consists of at least two
    # non-negative integers, separated by . or -
    if (!length(grep('^([0-9]+[.-])+[0-9]+$',rver))) {
        stop(paste('Not a valid R package version',rver))
    }

    # Debian policy says that an upstream version should start with a digit and
    # may only contain ASCII alphanumerics and '.+-:~'
    if (!length(grep('^[0-9][A-Za-z0-9.+:~-]*$',rver))) {
        stop(paste('R package version',rver
                  ,'does not obviously translate into a valid Debian version.'))
    }

    # if rver contains a : then the Debian version must also have a colon
    if (debian_epoch == 0 && length(grep(':',pkgver)))
        debian_epoch = 1

    # if the epoch is non-zero then include it
    if (debian_epoch != 0)
        pkgver = paste(debian_epoch,':',pkgver,sep='')

    # always add the '-1' Debian release; nothing is lost and rarely will R
    # packages be Debian packages without modification.
    return(paste(pkgver,'-',debian_revision,sep=''))
}

version.epoch <- function(pkgver) {
    # return the Debian epoch of a Debian package version
    if (!length(grep(':',pkgver)))
        return(0)
    return(as.integer(sub('^([0-9]+):.*','\\1',pkgver)))
}
# version.epoch . version.new(x,y) = id
# version.epoch(version.new(x,y)) = 0

version.revision <- function(pkgver) {
    # return the Debian revision of a Debian package version
    return(as.integer(sub('.*-([0-9]+)$','\\1',pkgver)))
}
# version.revision . version.new(x) = id
# version.revision(version.new(x)) = 1

version.upstream <- function(pkgver) {
    # return the upstream version of a Debian package version
    return(sub('-[0-9]+$','',sub('^[0-9]+:','',pkgver)))
}
# version.upstream . version.new = id

version.update <- function(rver, prev_pkgver) {
    prev_rver <- version.upstream(prev_pkgver)
    if (prev_rver == rver) {
        # increment the Debian revision
        return(version.new(rver
                          ,debian_revision = version.revision(prev_pkgver)+1
                          ,debian_epoch    = version.epoch(prev_pkgver)
                          ))
    }
    # new release
    # TODO: implement Debian ordering over version and then autoincrement
    #       Debian epoch when upstream version does not increment.
    return(version.new(rver
                      ,debian_epoch = version.epoch(prev_pkgver)
                      ))
}

# cd r-base-2.7.0/src/library
# find . -maxdepth 1 -type d  | sed -e 's,^..,'',' -e 's/$/'', /' | tr -d '\n'
# XXX: has to be a better way of doing this
base_pkgs=c('splines', 'stats4', 'Recommended', 'grid', 'base'
           ,'graphics', 'profile', 'stats', 'grDevices', 'datasets'
           ,'utils', 'tools', 'tcltk', 'methods')

pkgname.as.debian <- function(name,repo=NULL,version=NULL,binary=T) {
    if (name %in% base_pkgs) {
        name = 'R'
    }
    if (name == 'R') {
        # R is special.
        if (binary) {
            debname='r-base-core'
        } else {
            debname='r-base-dev'
        }
    } else {
        # TODO: if repo is NULL, then search for it in cran/bioc/etc
        # see ./src/library/tools/R/pkgDepends.R in R source
        debname = paste('r',tolower(repo),tolower(name),sep='-')
    }
    if (!is.null(version) && length(version) > 1) {
        debname = paste(debname,' (',version,')',sep='')
    }
    return(debname)
}

setup <- function() {
    tmp <- tempfile('cran2deb')
    dir.create(tmp)
    return (tmp)
}

cleanup <- function(dir) {
    unlink(dir,recursive=T)
    invisible()
}

prepare.pkg <- function(dir, pkgname,repo=default_repo,repoURL=default_repo_url) {
    # based loosely on library/utils/R/packages2.R::install.packages
    # should do nothing Debian specific
    archive <- download.packages(pkgname, dir, repos=repoURL, type="source")[1,2]
    if (length(grep('\\.\\.',archive)) || normalizePath(archive) != archive) {
        stop(paste('funny looking path',archive))
    }
    wd <- getwd()
    setwd(dir)
    if (length(grep('\\.zip$',archive))) {
        cmd = paste('unzip',shQuote(archive))
    } else if (length(grep('\\.tar\\.gz$',archive))) {
        cmd = paste('tar','xzf',shQuote(archive))
    } else {
        stop(paste('Type of archive',archive,'is unknown.'))
    }
    ret = system(cmd)
    setwd(wd)
    if (ret != 0) {
        stop(paste('Extraction of archive',archive,'failed.'))
    }
    pkg <- pairlist()
    pkg$name = pkgname
    pkg$archive = archive
    pkg$path = sub("_\\.(zip|tar\\.gz)", ""
                  ,gsub(.standard_regexps()$valid_package_version, ""
                  ,archive))
    if (!file.info(pkg$path)[,'isdir']) {
        stop(paste(pkg$path,'is not a directory and should be.'))
    }
    pkg$description = read.dcf(paste(pkg$path,'DESCRIPTION',sep='/'))
    pkg$repo = repo
    pkg$repoURL = repoURL
    pkg$version = pkg$description[1,'Version']
    return(pkg)
}

debian_ok_licenses=c('GPL','LGPL','AGPL','ARTISTIC','UNLIMITED'
                    ,'BSD','MIT','APACHE','X11','MPL')

is_acceptable_license <- function(license) {
    # compress spaces into a single space
    license = gsub('[[:blank:]]+',' ',license)
    # make all characters upper case
    license = toupper(license)
    # don't care about versions of licenses
    license = chomp(sub('\\( ?[<=>!]+ ?[0-9.]+ ?\\)',''
                    ,sub('-[0-9.]+','',license)))
    if (license %in% debian_ok_licenses) {
        return(T)
    }
    # uninteresting urls
    license = gsub('HTTP://WWW.GNU.ORG/[A-Z/.-]*','',license)
    license = gsub('HTTP://WWW.X.ORG/[A-Z/.-]*','',license)
    # remove all punctuation
    license = gsub('[[:punct:]]+','',license)
    # remove any extra space introduced
    license = chomp(gsub('[[:space:]]+',' ',license))
    # redundant
    license = gsub('THE','',license)
    license = gsub('STANDARD','',license)
    license = gsub('LICEN[SC]E','',license)
    license = gsub('(GNU )?(GPL|GENERAL PUBLIC)','GPL',license)
    license = gsub('(MOZILLA )?(MPL|MOZILLA PUBLIC)','MPL',license)
    # remove everything that looks like a version specification
    license = gsub('(VERSION|V)? *[0-9.]+ *(OR *(HIGHER|LATER|NEWER|GREATER|ABOVE))?',''
                   ,license)
    # remove any extra space introduced
    license = chomp(gsub('[[:space:]]+',' ',license))
    if (license %in% debian_ok_licenses) {
        message(paste('W: Accepted wild license as',license,'. FIX THE PACKAGE!'))
        return(T)
    }
    # TODO: put debian_ok_licenses in DB
    # TODO: file {LICENSE,LICENCE} (+ maybe COPYING?)
    message(paste('E: Wild license',license,'did not match'))
    return(F)
}

chomp <- function(x) {
    return(sub('^[[:space:]]+','',sub('[[:space:]]+$','',x)))
}

host.arch <- function() {
    system('dpkg-architecture -qDEB_HOST_ARCH',intern=T)
}

r.dependencies.of <- function(name=NULL,description=NULL,available) {
    if (is.null(description) && is.null(name)) {
        stop('must specify either a description or a name.')
    }
    if (is.null(description)) {
        description <- data.frame()
        if (!(name %in% dimnames(available)[[1]])) {
            stop(paste('package',name,'is not available from',repoURL))
        }
        # keep only the interesting fields
        for (field in r_depend_fields) {
            if (!(field %in% names(available[name,]))) {
                next
            }
            description[1,field] = available[name,field]
        }
    }
    # extract the dependencies from the description
    deps <- data.frame()
    for (field in r_depend_fields) {
        if (!(field %in% names(description[1,]))) {
            next
        }
        message(paste('examining description field',field,':',paste(description,collapse=', ')))
        for (dep in strsplit(chomp(description[1,field])
                                  ,'[[:space:]]*,[[:space:]]*')[[1]]) {
            if (is.na(dep)) {
                # XXX: this may be a bug, but for some reason NA's appear in
                #      this field at the end?
                next
            }
            # remove other comments
            dep = gsub('(\\(\\)|\\([[:space:]]*[^<=>!].*\\))','',dep)
            # squish spaces
            dep = chomp(gsub('[[:space:]]+',' ',dep))
            # parse version
            pat = '^([^ ()]+) ?(\\( ?([<=>!]+ ?[0-9.]+) ?\\))?$'
            if (!length(grep(pat,dep))) {
                stop(paste('R dependency',dep,'does not appear to be well-formed'))
            }
            version = sub(pat,'\\3',dep)
            dep = sub(pat,'\\1',dep)
            deps <- rbind(deps,data.frame(list(name=dep,version=version)))
        }
    }
    return (deps)
}

r.dependency.closure <- function(fringe,available,repo=default_repo) {
    closure <- list()
    fringe <- levels(fringe$name)
    while(length(fringe) > 0) {
        message(paste('fringe is',paste(fringe,collapse=', ')))
        message(paste('closure is',paste(closure,collapse=', ')))
        # pop off the top
        top <- fringe[[1]]
        if (length(fringe) > 1) {
            fringe <- fringe[2:length(fringe)]
        } else {
            fringe <- list()
        }
        src <- pkgname.as.debian(top,repo=repo,binary=F)
        message(paste('considering',top,'with source',src))
        if (!length(grep('^r-',src)) || length(grep('^r-base',src))) {
            message('...dropped')
            next
        }
        message('...kept!')
        # TODO: cross-repo dependencies
        newdeps <- levels(r.dependencies.of(name=top,available=available)$name)
        closure=c(closure,top)
        fringe=c(fringe,newdeps)
    }
    # build order
    return(rev(unique(closure)))
}

prepare.new.debian <- function(pkg) {
    maintainer = 'cran2deb buildbot <cran2deb@example.org>'

    # XXX: TODO: bundles do not work.
    if ('Bundle' %in% names(pkg$description[1,])) {
        stop('E: TODO: bundles')
    }

    # generate Debian version and name
    pkg$debversion = version.new(pkg$version)
    if (!length(grep('^[A-Za-z0-9][A-Za-z0-9+.-]+$',pkg$name))) {
        stop(paste('Cannot convert package name into a Debian name',pkg$name))
    }
    pkg$srcname = tolower(pkg$name)
    pkg$debname = pkgname.as.debian(pkg$srcname,repo=pkg$repo)

    if (!length(grep('\\.tar\\.gz',pkg$archive))) {
        stop('archive is not tarball')
    }

    # re-pack into a Debian-named archive with a Debian-named directory.
    debpath = paste(dirname(pkg$archive),'/'
                   ,pkg$srcname,'-'
                   ,pkg$version
                   ,sep='')
    file.rename(pkg$path, debpath)
    pkg$path = debpath
    debarchive = paste(dirname(pkg$archive),'/'
                              ,pkg$srcname,'_'
                              ,pkg$version,'.orig.tar.gz'
                              ,sep='')
    wd <- getwd()
    setwd(dirname(pkg$path))
    # remove them pesky +x files
    system(paste('find',shQuote(basename(pkg$path))
                ,'-type f -exec chmod -x {} \\;'))
    # tar it all back up
    system(paste('tar -czf',shQuote(debarchive),shQuote(basename(pkg$path))))
    setwd(wd)
    file.remove(pkg$archive)
    pkg$archive = debarchive

    # make the debian/ directory
    debdir <- paste(pkg$path,'debian',sep='/')
    debfile <- function(x) { paste(debdir,x,sep='/') }
    unlink(debdir,recursive=T)
    dir.create(debdir)

    # check the license
    if (!('License' %in% names(pkg$description[1,]))) {
        stop('package has no License: field in description!')
    }
    accept=NULL
    for (license in strsplit(chomp(pkg$description[1,'License'])
                            ,'[[:space:]]*\\|[[:space:]]*')[[1]]) {
        if (is_acceptable_license(license)) {
            accept=license
            break
        }
    }
    if (is.null(accept)) {
        stop(paste('No acceptable license:',pkg$description[1,'License']))
    } else {
        message(paste('N: Auto-accepted license',accept))
    }
    if (accept == 'Unlimited') {
        # definition of Unlimited from ``Writing R extensions''
        accept=paste('Unlimited (no restrictions on distribution or'
                    ,'use other than those imposed by relevant laws)')
    }

    # construct a dummy changelog
    # TODO: ``Writing R extensions'' mentions that a package may also have
    # {NEWS,ChangeLog} files.
    cat(paste(paste(pkg$srcname,' (',pkg$debversion,') unstable; urgency=low',sep='')
             ,'' ,'  * Initial release.',''
             ,paste(' --',maintainer,'',format(Sys.time(),'%a, %d %b %Y %H:%M:%S %z'))
             ,'',sep='\n'),file=debfile('changelog.in'))
    cat(paste('#!/usr/bin/make -f'
             ,'include /usr/share/R/debian/r-cran.mk'
             ,'',sep='\n')
       ,file=debfile('rules'))
    Sys.chmod(debfile('rules'),'0700')

    # generate copyright file; we trust DESCRIPTION
    writeLines(strwrap(
        paste('This Debian package of the GNU R package',pkg$name
             ,'was generated automatically using cran2deb by'
             ,paste(maintainer,'.',sep='')
             ,''
             ,'The original GNU R package is Copyright (C) '
             # TODO: copyright start date, true copyright date
             ,format(Sys.time(),'%Y')
             ,pkg$description[1,'Author']
             ,'and possibly others.'
             ,''
             ,'The original GNU R package is maintained by'
             ,pkg$description[1,'Maintainer'],'and was obtained from:'
             ,''
             ,pkg$repoURL
             ,''
             ,''
             ,'The GNU R package DESCRIPTION offers a'
             ,'Copyright licenses under the terms of the',accept
             ,'license.  On a Debian GNU/Linux system, common'
             ,'licenses are included in the directory'
             ,'/usr/share/common-licenses/.'
             ,''
             ,'The DESCRIPTION file for the original GNU R package '
             ,'can be found in '
             ,paste('/usr/lib/R/site-library'
                   ,pkg$debname
                   ,'DESCRIPTION'
                   ,sep='/')
             ,sep='\n'), width=72), con=debfile('copyright.in'))

    # see if this is an architecture-dependent package.
    # heuristic: if /src/ exists in pkg$path, then this is an
    #            architecture-dependent package.
    # CRAN2DEB.pm is a bit fancier about this but ``Writing R extensions''
    # says: ``The sources and headers for the compiled code are in src, plus
    # optionally file Makevars or Makefile.'' It seems unlikely that
    # architecture independent code would end up here.
    pkg$archdep = file.exists(paste(pkg$path,'src',sep='/'))
    pkg$arch <- 'all'
    if (pkg$archdep) {
        pkg$arch <- host.arch()
    }

    # determine dependencies
    avail <- available.packages(contriburl=contrib.url(pkg$repoURL))
    dependencies <- r.dependencies.of(description=pkg$description
                                     ,available=avail)
    depends <- list()
    # these are used for generating the Depends fields
    as.deb <- function(r) {
        return(pkgname.as.debian(dependencies[r,]$name
                                ,version=dependencies[r,]$version))
    }
    depends$bin <- lapply(rownames(dependencies), as.deb, repo=repo, binary=T)
    depends$build <- lapply(rownames(dependencies), as.deb, repo=repo, binary=F)

    # make sure we depend upon R in some way...
    if (!length(grep('^r-base',depends$build))) {
        depends$build = c(depends$build,pkgname.as.debian('R',version='>= 2.7.0',binary=F))
        depends$bin   = c(depends$bin,  pkgname.as.debian('R',version='>= 2.7.0',binary=T))
    }

    # the names of dependent source packages (to find the .changes file to
    # upload via dput). these can be found recursively.
    depends$r <- r.dependency.closure(dependencies,available=avail,repo=pkg$repo)

    # remove duplicates
    depends <- lapply(depends,unique)

    # append the Debian dependencies
    depends$build=c(depends$build,'debhelper (>> 4.1.0)','cdbs')
    if (pkg$archdep) {
        depends$bin=c(depends$bin,'${shlibs:Depends}')
    }
    pkg$r.depends = depends$r

    # construct control file
    control = data.frame()
    control[1,'Source'] = pkg$srcname
    control[1,'Section'] = 'math'
    control[1,'Priority'] = 'optional'
    control[1,'Maintainer'] = maintainer
    control[1,'Build-Depends'] = paste(depends$build,collapse=', ')
    control[1,'Standards-Version'] = '3.7.3.0'

    control[2,'Package'] = pkg$debname
    control[2,'Architecture'] = 'all'
    if (pkg$archdep) {
        control[2,'Architecture'] = 'any'
    }
    control[2,'Depends'] = paste(depends$bin,collapse=', ')
    descr = 'GNU R package "'
    if ('Title' %in% colnames(pkg$description)) {
        descr = paste(descr,pkg$description[1,'Title'],sep='')
    } else {
        descr = paste(descr,pkg$name,sep='')
    }
    # using \n\n.\n\n is not very nice, but is necessary to make sure
    # the longer description does not begin on the synopsis line --- R's
    # write.dcf does not appear to have a nicer way of doing this.
    descr = paste(descr,'"\n\n', pkg$description[1,'Description'], sep='')
    if ('URL' %in% colnames(pkg$description)) {
        descr = paste(descr,'\n\nURL: ',pkg$description[1,'URL'],sep='')
    }
    control[2,'Description'] = descr
    # Debian policy says 72 char width; indent minimally
    write.dcf(control,file=debfile('control.in'),indent=1,width=72)
    write.dcf(control,indent=1,width=72)

    # TODO: debian/watch from pkg$repoURL

    # convert text to utf8 (who knows what the original character set is --
    # let's hope iconv DTRT).
    for (file in c('control','changelog','copyright')) {
        system(paste('iconv -o ',shQuote(debfile(file))
                    ,' -t utf8 '
                    ,shQuote(debfile(paste(file,'in',sep='.')))))
        file.remove(debfile(paste(file,'in',sep='.')))
    }
    return(pkg)
}

build.debian <- function(pkg) {
    wd <- getwd()
    setwd(pkg$path)
    message(paste('N: building Debian package'
                 ,pkg$debname
                 ,paste('(',pkg$debversion,')',sep='')
                 ,'...'))
    ret = system(paste('pdebuild --configfile',pbuilder_config))
    setwd(wd)
    if (ret != 0) {
        stop('Failed to build package.')
    }
}


# TEST: SRPM -> stashR -> digest -> filehash
go <- function(name) {
    dir <- setup()
    pkg <- try((function() {
        pkg <- prepare.new.debian(prepare.pkg(dir,name))

        # delete the current archive (XXX: assumes mini-dinstall)
        for (subdir in c('/mini-dinstall','/unstable')) {
            path = paste(dinstall_archive,subdir,sep='')
            if (file.exists(path)) {
                unlink(path,recursive=T)
            }
        }

        # delete notes of upload
        file.remove(Sys.glob(paste(pbuilder_results,'*.upload',sep='/')))

        # make mini-dinstall generate the skeleton of the archive
        ret = system(paste('umask 022;mini-dinstall --batch -c',dinstall_config))
        if (ret != 0) {
            stop('failed to create archive')
        }

        # pull in all the R dependencies
        message(paste('N: dependencies:',pkg$r.depends,collapse=', '))
        for (dep in pkg$r.depends) {
            message(paste('N: uploading',dep))
            ret = system(paste('umask 022;dput','-c',shQuote(dput_config),'local'
                        ,paste(pbuilder_results, '/'
                              ,paste(dep,'_*_'
                                    ,host.arch(),'.changes',sep=''), sep='')))
            if (ret != 0) {
                stop('upload of dependency failed! maybe you did not build it first?')
            }
        }
        build.debian(pkg)

        # upload the package
        ret = system(paste('umask 022;dput','-c',shQuote(dput_config),'local'
                    ,paste('/', pbuilder_results, '/'
                          ,paste(pkg$srcname,'_',pkg$debversion,'_'
                                ,host.arch(),'.changes',sep=''), sep='')))
        if (ret != 0) {
            stop('upload failed!')
        }

        return(pkg)
    })())
    cleanup(dir)
    if (inherits(pkg,'try-error')) {
        stop(call.=F)
    }
    return(pkg)
}

if (exists('argv')) { # check for littler
    for (arg in argv) {
        go(arg)
    }
}
